:icons:
:linkcss:
:imagesdir: ../images

= Kubernetes ConfigMap and Secrets
:toc:

Kubernetes has resource types that allows to decouple application code from configuration. It makes the applications to be more portable. This chapter will cover how ConfigMap and Secrets can be used to do that.

. ConfigMap is just a set of key-value pairs. It allow you to decouple configuration artifacts from image content.
. Secrets allows separating sensitive information such as credentials and keys from an application.

ConfigMap is similar to Secrets, but provides a means of working with strings that donâ€™t contain sensitive information.

This section will explain how to use ConfigMap and Secrets.

== ConfigMap

We will illiustrate how to pass configuration information to a Redis pod using ConfigMap.

=== Create a ConfigMap object

Create a ConfigMap:

    kubectl apply -f ./templates/config-map.yaml

`config-map.yaml` defines the configuration information as:

```
data:
  redis-config: |
    maxmemory 2mb
    maxmemory-policy allkeys-lru
```

Get the list of created ConfiMaps:

```
$ kubectl get configmap
NAME           DATA      AGE
redis-config   1         4m
```

Get more details about the created ConfigMap:

```
kubectl describe configmap/redis-config
$ Name:         redis-config
Namespace:    default
Labels:       k8s-app=redis
Annotations:  kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","data":{"redis-config":"maxmemory 2mb\nmaxmemory-policy allkeys-lru\n"},"kind":"ConfigMap","metadata":{"annotations":{},"labels":{"k...

Data
====
redis-config:
----
maxmemory 2mb
maxmemory-policy allkeys-lru

Events:  <none>
```

In this case, we created a ConfigMap using a resource configuration file. Other ways to create ConfigMap are listed below:

. `kubectl create configmap --from-literal=<key>:<value>`. Multiple `--from-literal=<key>:<value>` options can be used to define different key/value pairs
. `kubectl create configmap redis-config --from-file=<properties file>` where `<properties file>` is a property file with key/value pairs
. `kubectl create configmap redis-config --from-file=<directory>` where `<directory>` is a directory that consists of property files with key/value pairs

=== Deploy a Redis pod

Deploy a Redis pod that maps the ConfigMap to the volume where the configuration resides:

    kubectl apply -f ./templates/redis-pod.yaml

=== Validate Redis cluster

Validate that your redis cluster picked up the appropriate configuration:

    kubectl exec --it redis redis-cli
    CONFIG GET maxmemory
    CONFIG GET maxmemory-policy

You should see the same values that were specified in the ./templates/config-map.yaml outputted in the above commands.

== Secrets

In this section we will demonstrate how to place secrets into the Kubernetes cluster and then show multiple ways of retrieving those secretes from within pods.

=== Create secrets

First encode the secrets you want to apply, for this example we will use the username `admin` and the password `password`

    echo -n "admin" | base64
    echo -n "password" | base64

Both of these values are already written in the file `./templates/secret.yaml`

You can now insert this secret in to kubernetes with the following command:

    kubectl apply -f ./templates/secret.yaml

=== Consume secrets

Here we will demonstrate two ways to consume secrets from within pods.

==== Using volumes

Deploy the pod:

    kubectl apply -f ./templates/pod-secret-volume.yaml

Open a shell to the pod to see the secrets

    kubectl exec -it pod-secret-volume /bin/bash
    ls /etc/foo
    cat /etc/foo/username ; echo
    cat /etc/foo/password ; echo

The above commands should result in the plain text values, the decoding is done for you.

==== Using Environment Variables

Deploy the pod:

    kubectl apply -f ./templates/pod-secret-env.yaml

Open a shell to the pod to see the secrets:

    kubectl exec -it pod-secret-volume /bin/bash
    echo $SECRET_USERNAME
    echo $SECRET_PASSWORD

The above commands illustrate how to see the secret values via environment variables

