= Kubernetes - First Steps with the Kubernetes CLI
:icons:
:linkcss:
:imagesdir: ../images
:toc:

Before starting this section, please have created  a highly available cluster on AWS using https://github.com/kubernetes/kops[kops], as explained here: link:../cluster-install[cluster install] section.

== Kubernetes basic commands

Now that we have a cluster up and running we can start issuing some basic commands and deploy some simple resources.

In this part we will familiarize ourselves with the `kubectl` CLI tool and basic Kubernetes commands. We will first deploy a basic NGiNX pod and execute some commands to help developers gain comfort with the Kubernetes environment from an end-user perspective. This helps get developers up and running taking advantage of the Kubernetes application deployment capabilities without having to worry about the infrastructure related complexities.

NOTE: The kubectl commands below will be routed via your virtualbox network interface. If you are using a VPN or have a local firewall, this may prevent kubectl from contacting the minikube endpoint. Stopping the VPN or adding a firewall rule may resolve this.

=== Display nodes

This command will show all the nodes available in your kubernetes cluster:

    $ kubectl get nodes

It will show an output similar to:

    NAME                                           STATUS    ROLES     AGE      VERSION
    ip-172-20-105-158.us-east-2.compute.internal   Ready     node      2d       v1.7.4
    ip-172-20-124-26.us-east-2.compute.internal    Ready     master    2d       v1.7.4
    ip-172-20-127-251.us-east-2.compute.internal   Ready     node      2d       v1.7.4
    ip-172-20-52-35.us-east-2.compute.internal     Ready     master    2d       v1.7.4
    ip-172-20-63-150.us-east-2.compute.internal    Ready     node      2d       v1.7.4
    ip-172-20-71-14.us-east-2.compute.internal     Ready     node      2d       v1.7.4
    ip-172-20-87-91.us-east-2.compute.internal     Ready     node      2d       v1.7.4
    ip-172-20-94-153.us-east-2.compute.internal    Ready     master    2d       v1.7.4

=== Create your first pod

This command creates an nginx pod into your cluster:

    $ kubectl run nginx --image=nginx
    deployment "nginx" created

Get the list of deployments:

    $ kubectl get deployments
    NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
    nginx     1         1         1            0           41s

Get the list of running pods:

    $ kubectl get pods
    NAME                     READY     STATUS    RESTARTS   AGE
    nginx-4217019353-pmkzb   1/1       Running   0          1m

Get additional details for the pod by using the `<pod-name>` from the above output:

```
$ kubectl describe pod/nginx-4217019353-pmkzb
kubectl describe pod/nginx-4217019353-pmkzb
Name:           nginx-4217019353-pmkzb
Namespace:      default
Node:           ip-172-20-87-91.us-east-2.compute.internal/172.20.87.91
Start Time:     Fri, 01 Dec 2017 16:36:48 -0800
Labels:         pod-template-hash=4217019353
                run=nginx
Annotations:    kubernetes.io/created-by={"kind":"SerializedReference","apiVersion":"v1","reference":{"kind":"ReplicaSet","namespace":"default","name":"nginx-4217019353","uid":"e161abe9-d6f8-11e7-af8f-06c4465216f2","...
                kubernetes.io/limit-ranger=LimitRanger plugin set: cpu request for container nginx
Status:         Running
IP:             100.96.7.19
Created By:     ReplicaSet/nginx-4217019353
Controlled By:  ReplicaSet/nginx-4217019353
Containers:
  nginx:
    Container ID:   docker://2def6a6dc1594c337748abf6160ff81fab9fa6d734aca02b5f1afc4d395edc6b
    Image:          nginx
    Image ID:       docker-pullable://nginx@sha256:b81f317384d7388708a498555c28a7cce778a8f291d90021208b3eba3fe74887
    Port:           <none>
    State:          Running
      Started:      Fri, 01 Dec 2017 16:36:52 -0800
    Ready:          True
    Restart Count:  0
    Requests:
      cpu:        100m
    Environment:  <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-cqht0 (ro)
Conditions:
  Type           Status
  Initialized    True 
  Ready          True 
  PodScheduled   True 
Volumes:
  default-token-cqht0:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-cqht0
    Optional:    false
QoS Class:       Burstable
Node-Selectors:  <none>
Tolerations:     node.alpha.kubernetes.io/notReady:NoExecute for 300s
                 node.alpha.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason                 Age   From                                                 Message
  ----    ------                 ----  ----                                                 -------
  Normal  Scheduled              46s   default-scheduler                                    Successfully assigned nginx-4217019353-pmkzb to ip-172-20-87-91.us-east-2.compute.internal
  Normal  SuccessfulMountVolume  46s   kubelet, ip-172-20-87-91.us-east-2.compute.internal  MountVolume.SetUp succeeded for volume "default-token-cqht0"
  Normal  Pulling                46s   kubelet, ip-172-20-87-91.us-east-2.compute.internal  pulling image "nginx"
  Normal  Pulled                 42s   kubelet, ip-172-20-87-91.us-east-2.compute.internal  Successfully pulled image "nginx"
  Normal  Created                42s   kubelet, ip-172-20-87-91.us-east-2.compute.internal  Created container
  Normal  Started                42s   kubelet, ip-172-20-87-91.us-east-2.compute.internal  Started container

```

By default, pods are created in a `default` namespace. In addition, a `kube-system` namespace is also reserved for Kubernetes system pods. A list of all the pods in `kube-system` namespace can be displayed as shown:

```
$ kubectl get pods --namespace kube-system
NAME                                                                  READY     STATUS    RESTARTS   AGE
dns-controller-3497129722-4pxd6                                       1/1       Running   0          28d
etcd-server-events-ip-172-20-124-26.us-east-2.compute.internal        1/1       Running   0          28d
etcd-server-events-ip-172-20-52-35.us-east-2.compute.internal         1/1       Running   0          28d
etcd-server-events-ip-172-20-94-153.us-east-2.compute.internal        1/1       Running   0          28d
etcd-server-ip-172-20-124-26.us-east-2.compute.internal               1/1       Running   0          28d
etcd-server-ip-172-20-52-35.us-east-2.compute.internal                1/1       Running   0          28d
etcd-server-ip-172-20-94-153.us-east-2.compute.internal               1/1       Running   0          28d
kube-apiserver-ip-172-20-124-26.us-east-2.compute.internal            1/1       Running   0          28d
kube-apiserver-ip-172-20-52-35.us-east-2.compute.internal             1/1       Running   0          28d
kube-apiserver-ip-172-20-94-153.us-east-2.compute.internal            1/1       Running   0          28d
kube-controller-manager-ip-172-20-124-26.us-east-2.compute.internal   1/1       Running   0          28d
kube-controller-manager-ip-172-20-52-35.us-east-2.compute.internal    1/1       Running   0          28d
kube-controller-manager-ip-172-20-94-153.us-east-2.compute.internal   1/1       Running   0          28d
kube-dns-1311260920-jgl0m                                             3/3       Running   0          28d
kube-dns-1311260920-tvpmp                                             3/3       Running   0          28d
kube-dns-autoscaler-1818915203-5kxrb                                  1/1       Running   0          28d
kube-proxy-ip-172-20-105-158.us-east-2.compute.internal               1/1       Running   0          28d
kube-proxy-ip-172-20-124-26.us-east-2.compute.internal                1/1       Running   0          28d
kube-proxy-ip-172-20-127-251.us-east-2.compute.internal               1/1       Running   0          28d
kube-proxy-ip-172-20-52-35.us-east-2.compute.internal                 1/1       Running   0          28d
kube-proxy-ip-172-20-63-150.us-east-2.compute.internal                1/1       Running   0          28d
kube-proxy-ip-172-20-71-14.us-east-2.compute.internal                 1/1       Running   0          28d
kube-proxy-ip-172-20-87-91.us-east-2.compute.internal                 1/1       Running   0          28d
kube-proxy-ip-172-20-94-153.us-east-2.compute.internal                1/1       Running   0          28d
kube-scheduler-ip-172-20-124-26.us-east-2.compute.internal            1/1       Running   0          28d
kube-scheduler-ip-172-20-52-35.us-east-2.compute.internal             1/1       Running   0          28d
kube-scheduler-ip-172-20-94-153.us-east-2.compute.internal            1/1       Running   0          28d
tiller-deploy-1114875906-k2pj2                                        1/1       Running   0          28d
```
Again, the exact output may vary but your results should look similar to these.

=== Get logs from the pod

Logs from the pod can be obtained (a fresh nginx does not have logs - check again later once you have accessed the service):

    $ kubectl logs <pod-name>

=== Execute a shell on the running pod

This command will open a TTY to a shell in your pod:

    $ kubectl get pods
    $ kubectl exec -it <pod-name> /bin/bash

This opens a Bash shell and allows you to look around the filesystem of the container.

=== Expose the deployment as a Service

By default, all Kubernetes resources are only accessible within the cluster. This command will create a loadBalancer and allow the the NGiNX deployment to be accessible from the Internet:

    $ kubectl expose deployment nginx --type=LoadBalancer --port=80 --target-port=80 --name=web
    service "web" exposed

This will expose the deployment as a Service. You can see the published service:

    $ kubectl get service
    NAME         TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)        AGE
    kubernetes   ClusterIP      100.64.0.1      <none>             443/TCP        2d
    web          LoadBalancer   100.69.223.33   a904073d0d6fe...   80:31259/TCP   32s

We will learn more about Services and Deployments later in the workshop.    

=== View Service webpage

We can find the hostname of the LoadBalancer created when we exposed the nginx deployment as service.
The `-o` flag allows us to choose a different output format, and choosing the `jsonpath` output format allows us to filter the resultant JSON down to the exact value we need. 

    $ kubectl get service web -o jsonpath={.status.loadBalancer.ingress..hostname}
    a904073d0d6fe11e7af8f06c4465216f-766639162.us-east-2.elb.amazonaws.com

Placing that hostname into a browser should show the default NGiNX homepage.

=== Delete resources

Delete all the Kubernetes resources created so far:

    $ kubectl delete service/web deployment/nginx

