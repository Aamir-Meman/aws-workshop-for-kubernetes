= Using CoreDNS for Service Discovery - WIP
:toc:

https://github.com/kubernetes/kubernetes/tree/master/cluster/addons/dns[kube-dns] is a Kubernetes cluster add-on that is launched as part of cluster creation. It schedules a DNS Pod and Service on the cluster, and configures the kubelets to tell other pods and containers to use the DNS service IP's to resolve DNS names.

https://coredns.io/[CoreDNS] implements the https://github.com/kubernetes/dns/blob/master/docs/specification.md[spec] defined for Kubernetes DNS-based service discovery. This allows kube-dns to be replaced by CoreDNS.

This chapter will explain how to update an existing Kubernetes cluster to use CoreDNS instead of the default kube-dns.

== Pre-requisites

A 3 master nodes and 5 worker nodes cluster as explained at link:../cluster-install#multi-master-multi-node-multi-az-gossip-based-cluster[] is used for this chapter.

All configuration files for this chapter are in the `coredns` directory.

== Status Quo

Each Kubernetes cluster has a service named `kube-dns` that forwards all DNS requests to the pod responsible for handling DNS requests. This service can be seen as:

	$ kubectl get svc -n kube-system
	NAME       TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)         AGE
	kube-dns   ClusterIP   100.64.0.10   <none>        53/UDP,53/TCP   8m

More details about the service can be found:

	$ kubectl describe svc kube-dns -n kube-system
	Name:              kube-dns
	Namespace:         kube-system
	Labels:            k8s-addon=kube-dns.addons.k8s.io
	                   k8s-app=kube-dns
	                   kubernetes.io/cluster-service=true
	                   kubernetes.io/name=KubeDNS
	Annotations:       kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"labels":{"k8s-addon":"kube-dns.addons.k8s.io","k8s-app":"kube-dns","kubernetes.io/clu...
	Selector:          k8s-app=kube-dns
	Type:              ClusterIP
	IP:                100.64.0.10
	Port:              dns  53/UDP
	TargetPort:        53/UDP
	Endpoints:         100.96.3.2:53,100.96.4.2:53
	Port:              dns-tcp  53/TCP
	TargetPort:        53/TCP
	Endpoints:         100.96.3.2:53,100.96.4.2:53
	Session Affinity:  None
	Events:            <none>

To validate that the current DNS setup is working we first have to deploy a `busybox` pod:

	$ kubectl create -f templates/busybox.yaml
	pod "busybox" created

Lets resolve the `kubernetes` service in the `default` namespace:

```
$ kubectl exec -ti busybox -- nslookup kubernetes.default
Server:    100.64.0.10
Address 1: 100.64.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes.default
Address 1: 100.64.0.1 kubernetes.default.svc.cluster.local
```

The output shows that the `kube-dns` service answered the request and the `kubernetes` service can be found at `100.64.01`.

Lets look at the `resolv.conf`:

	$ kubectl exec busybox cat /etc/resolv.conf
	nameserver 100.64.0.10
	search default.svc.cluster.local svc.cluster.local cluster.local eu-central-1.compute.internal
	options ndots:5

As expected, the nameserver IP corresponds to the IP of the `kube-dns` service. Additionally, the search domains also reflect the expected kubernetes schema (get more https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/[here]).

== Deploy CoreDNS

The CoreDNS deployment relies on information that is specific to you cluster: CIDR of the kubernetes services and cluster domain.

For kops, `coredns` can be deployed:

	$ kubectl create -f templates/coredns-kops.yaml
	serviceaccount "coredns" created
	clusterrole "system:coredns" created
	clusterrolebinding "system:coredns" created
	configmap "coredns" created
	deployment "coredns" created

NOTE: If you use minikube, run `kubectl create -f templates/coredns-kops.yaml` instead and replace the `clusterIP` in `templates/coredns-service.yaml` with the result from `kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}`.

Wait until CoreDNS pod is running:

	$ kubectl get po -l k8s-app=coredns -n kube-system
	NAME                       READY     STATUS    RESTARTS   AGE
	coredns-3986650266-4x4sp   1/1       Running   0          13s

== Switching to CoreDNS

We need to update the Kube-DNS service to use our CoreDNS pod:

	$ kubectl apply -f templates/coredns-service.yaml

Now, when you describe the `kube-dns` service now, it should look something like this:

	kubectl describe svc kube-dns -n kube-system
	Name:			kube-dns
	Namespace:		kube-system
	Labels:			k8s-app=coredns
				kubernetes.io/cluster-service=true
				kubernetes.io/name=CoreDNS
	Annotations:		kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"labels":{"k8s-app":"coredns","kubernetes.io/cluster-service":"true","kubernetes.io/na...
	Selector:		k8s-app=coredns
	Type:			ClusterIP
	IP:			10.0.0.10
	Port:			dns	53/UDP
	Endpoints:		172.17.0.10:53
	Port:			dns-tcp	53/TCP
	Endpoints:		172.17.0.10:53
	Port:			metrics	9153/TCP
	Endpoints:		172.17.0.10:9153
	Session Affinity:	None
	Events:			<none>

If all went correct, the IP of our CoreDNS pod should match the endpoint IPs in the kube-dns service:

	kubectl get po -l k8s-app=coredns -n kube-system -o wide
	NAME                       READY     STATUS    RESTARTS   AGE       IP            NODE
	coredns-3986650266-gw79f   1/1       Running   0          20m       172.17.0.10   ip-172-20-102-248.eu-central-1.compute.internal

Awesome, this fits nicely!

To be completely sure, you can re-execute the commands from the <<Status Quo>> section which validate the setup.

== Delete kube-dns deployment (optional)

As a very last step we can delete the original kube-dns deployment:

	kubectl delete deployment kube-dns -n kube-system

This will delete the pod, and the CoreDNS implementation will still be available.
